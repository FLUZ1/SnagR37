<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Qualidade e Segurança</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>

    <style>
        :root {
            --cor-primaria: #01455C;
            --cor-secundaria: #9FC419;
            --cor-alerta: #ef4444;
            --cor-aviso: #f39c12;
            --cor-info: #3498db;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--cor-primaria);
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--cor-primaria);
            color: white;
            padding: 15px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* Estilo Adicional para o Seletor de Projeto */
        .project-selector-group {
            min-width: 200px;
            margin-left: 20px; /* Espaçamento à esquerda */
        }
        .project-selector-group label {
            color: white; /* Cor do label */
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: 600;
        }
        .project-selector-group select {
             width: 100%;
            padding: 8px 10px; /* Ajuste no padding */
            border: 1.5px solid white; /* Borda branca */
            border-radius: 5px;
            background-color: var(--cor-primaria);
            font-size: 14px;
            box-sizing: border-box;
            color: white;
            font-weight: 700;
            cursor: pointer;
        }
        /* Ajuste para o ícone do dropdown no select */
         .project-selector-group select {
             appearance: none;
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='white' viewBox='0 0 20 20'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd' /%3E%3C/svg%3E");
             background-repeat: no-repeat;
             background-position: right 0.7rem center;
             background-size: 1.2em 1.2em;
             padding-right: 2.5rem; /* Espaço para o ícone */
         }


        .filters {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-end;
        }

        .filter-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark-color);
            font-size: 14px;
        }

        select, input[type="date"] { /* Aplicar estilo base para select e date */
            width: 100%;
            padding: 10px;
            border: 1.5px solid var(--cor-primaria);
            border-radius: 5px;
            background-color: var(--cor-primaria);
            font-size: 14px;
            box-sizing: border-box;
            color: white;
            font-weight: 700;
        }

        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }

        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 20px;
            margin-bottom: 20px;
            color: black; /* Garante texto preto dentro dos cards */
        }

        .card-header {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: 700;
            color: var(--cor-primaria);
        }

        .card-subheader {
            font-size: 14px;
            color: #777;
            margin-top: -15px;
            margin-bottom: 20px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 20px;
            text-align: center;
            border-left: 5px solid var(--cor-primaria);
            color: black; /* Garante texto preto nos stat cards */
        }

        .stat-card.alerta { border-left-color: var(--cor-alerta); }
        .stat-card.sucesso { border-left-color: var(--cor-secundaria); }

        .stat-value {
            font-size: 32px;
            font-weight: 900;
            margin: 10px 0 5px 0;
        }

        .stat-value.primaria { color: var(--cor-primaria); }
        .stat-value.alerta { color: var(--cor-alerta); }
        .stat-value.sucesso { color: var(--cor-secundaria); }

        .stat-label {
            color: #777;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .chart-container {
            position: relative;
            width: 100%;
        }

        .tabs {
            border-bottom: 2px solid #dee2e6;
            margin-bottom: 20px;
        }
        .tab-link {
            padding: 10px 20px; cursor: pointer; border: none; background-color: transparent;
            color: white; font-size: 18px; font-weight: 600;
            border-bottom: 3px solid transparent; transition: all 0.3s ease;
        }
        .tab-link.active {
            color: var(--cor-secundaria);
            border-bottom-color: var(--cor-secundaria);
        }
        #scatter-legend-table {
            display: flex; justify-content: space-around; width: 100%;
            margin-top: 20px; font-size: 12px; color: black;
        }
        #scatter-legend-table h3 {
            font-weight: bold; color: var(--cor-primaria); border-bottom: 2px solid var(--cor-primaria);
            padding-bottom: 5px; margin-bottom: 10px;
        }
        #scatter-legend-table ol { list-style-position: inside; padding-left: 0; }
        #scatter-legend-table li { margin-bottom: 5px; display: flex; align-items: center; }
        #scatter-legend-table .legend-color-box {
            width: 12px; height: 12px; margin-right: 8px; border: 1px solid #ccc;
        }

        #inference-section {
            margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; color: black;
        }
        #inference-section > h3 {
            font-size: 1.5em; font-weight: 700; color: var(--cor-primaria);
            margin-bottom: 20px; text-align: center;
        }
        #inference-section .inference-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        #inference-section .inference-card {
            padding: 20px; border-radius: 8px; background-color: #f8f9fa;
            border-left: 5px solid #ccc;
        }
        #inference-section .inference-card.criticos { border-left-color: var(--cor-alerta); }
        #inference-section .inference-card.eficientes { border-left-color: var(--cor-secundaria); }
        #inference-section .inference-card.ineficientes { border-left-color: var(--cor-aviso); }

        #inference-section .inference-card-header {
            display: flex; align-items: center; margin-bottom: 12px;
        }
        #inference-section .inference-card-header svg {
            width: 32px; height: 32px; margin-right: 12px;
        }
        #inference-section .inference-card-header h4 {
            font-size: 1.1em; font-weight: 700; color: var(--dark-color);
        }
        #inference-section .inference-card p {
            font-size: 0.9em; color: #555; margin-bottom: 10px;
        }
        #inference-section .inference-tag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .inference-category-tag {
            padding: 4px 10px; border-radius: 12px;
            font-size: 0.8em; font-weight: 500;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .inference-card.criticos .inference-category-tag {
            background-color: var(--cor-alerta); color: white;
        }
        .inference-card.criticos .inference-category-tag:hover {
            background-color: #c0392b; transform: scale(1.05);
        }
        .inference-card.eficientes .inference-category-tag {
            background-color: var(--cor-secundaria); color: var(--dark-color);
        }
        .inference-card.eficientes .inference-category-tag:hover {
            background-color: #82a013; color: white; transform: scale(1.05);
        }
        .inference-card.ineficientes .inference-category-tag {
            background-color: var(--cor-aviso); color: white;
        }
        .inference-card.ineficientes .inference-category-tag:hover {
            background-color: #d35400; transform: scale(1.05);
        }

        #modal-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); display: none;
            justify-content: center; align-items: center; z-index: 1000;
        }
        #modal-content {
            background-color: white; color: black; padding: 25px;
            border-radius: 8px; width: 90%; max-width: 500px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #modal-title {
            font-size: 1.25em; font-weight: 600; color: var(--cor-primaria);
            margin: 0 0 15px 0; padding-bottom: 10px; border-bottom: 1px solid #eee;
        }
        #modal-body ol { list-style-position: inside; }
        #modal-body li { margin-bottom: 8px; }
        #modal-close-btn {
            background-color: var(--cor-primaria); color: white;
            border: none; padding: 10px 20px; border-radius: 5px;
            cursor: pointer; margin-top: 20px; float: right;
        }

        #progress-bar {
            transition: width 0.3s ease-in-out;
        }

        /* Ajuste do Header para incluir o seletor de projeto */
        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Permite quebrar linha se não couber */
        }
         header .header-left {
             display: flex;
             align-items: center; /* Alinha verticalmente título e seletor */
             flex-grow: 1; /* Permite ocupar espaço */
             margin-right: 20px; /* Espaço antes do botão de imprimir */
         }

        @media print {
            body { background-color: #fff !important; color: #000 !important; }
            header, footer, .tabs, .filters, #modal-container { display: none !important; }
            main#dashboard-content, .tab-content { display: block !important; }
            .card { box-shadow: none !important; border: 1px solid #ddd !important; page-break-inside: avoid !important; }
            .stat-card { border: 1px solid #ddd !important; }
            .chart-container { height: 350px !important; width: 100%; }
            h1.text-3xl { color: black !important; }
            #inference-section, #scatter-legend-table { color: black !important; }
            #inference-section .inference-card { background-color: #fff !important; }
        }
    </style>
</head>
<body class="text-gray-800 dark:text-gray-200 flex flex-col min-h-screen">

    <div class="flex-grow p-4 sm:p-6 lg:p-8">
        <header class="mb-8">
            <div class="container mx-auto">
                <div class="header-left">
                     <div>
                         <h1 class="text-3xl font-bold text-white dark:text-white">Dashboard de Análise de Apontamentos</h1>
                         <p class="text-gray-300 dark:text-gray-400">Relatório Interativo do SnagR</p>
                     </div>
                     <div class="project-selector-group">
                         <label for="project-selector">Selecionar Projeto</label>
                         <select id="project-selector">
                             <option value="Hotel.jsonl" selected>Hotel</option>
                             <option value="Centro medico.jsonl">Centro Medico</option>
                             <option value="Ensino.jsonl">Ensino</option>
                             <option value="Residencial.jsonl">Residencial</option>
                             <option value="Embasamento.jsonl">Embasamento</option>
                         </select>
                     </div>
                 </div>
                 </div>
        </header>

        <div id="initial-message" class="initial-message text-center py-10 text-gray-200 text-lg">
            <p>Carregando dados do projeto...</p> </div>

        <div id="loading-container" class="text-center py-10" style="display: none;">
            <p id="loading-status" class="text-gray-200 text-lg mb-4">Iniciando...</p>
            <div id="progress-bar-container" class="w-full max-w-md mx-auto bg-gray-600 rounded-full h-2.5">
                <div id="progress-bar" class="bg-[--cor-secundaria] h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>

        <div id="error-message" class="error bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" style="display: none;" role="alert"></div>

        <main id="dashboard-content" style="display: none;">
            <div class="tabs">
                <button class="tab-link active" onclick="openTab(event, 'visaoGeral')">Visão Geral</button>
                <button class="tab-link" onclick="openTab(event, 'eficiencia')">Eficiência (SLA)</button>
                <button class="tab-link" onclick="openTab(event, 'localizacao')">Análise por Localização</button>
            </div>

            <div id="visaoGeral" class="tab-content">
                <div class="filters">
                    <div class="filter-group">
                        <label for="spotted-filter">Data (Spotted)</label>
                        <input type="date" id="spotted-filter">
                    </div>
                    <div class="filter-group">
                        <label for="year-filter">Ano</label>
                        <select id="year-filter">
                            <option value="all">Todos</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="month-filter">Mês</label>
                        <select id="month-filter">
                            <option value="all">Todos</option>
                            <option value="0">Janeiro</option>
                            <option value="1">Fevereiro</option>
                            <option value="2">Março</option>
                            <option value="3">Abril</option>
                            <option value="4">Maio</option>
                            <option value="5">Junho</option>
                            <option value="6">Julho</option>
                            <option value="7">Agosto</option>
                            <option value="8">Setembro</option>
                            <option value="9">Outubro</option>
                            <option value="10">Novembro</option>
                            <option value="11">Dezembro</option>
                        </select>
                    </div>
                </div>

                <div class="stats grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6">
                    <div class="stat-card"><div class="stat-label">Total</div><div class="stat-value primaria" id="total-records">0</div></div>
                    <div class="stat-card alerta"><div class="stat-label">Em Aberto</div><div class="stat-value alerta" id="open-records">0</div></div>
                    <div class="stat-card sucesso"><div class="stat-label">Fechados</div><div class="stat-value sucesso" id="closed-records">0</div></div>
                    <div class="stat-card sucesso"><div class="stat-label">Assinados</div><div class="stat-value sucesso" id="signed-off-records">0</div></div>
                    <div class="stat-card"><div class="stat-label">Não Aceitos</div><div class="stat-value primaria" id="not-accepted-records">0</div></div>
                    <div class="stat-card sucesso"><div class="stat-label">Taxa de Resolução</div><div class="stat-value sucesso" id="resolution-rate">0%</div></div>
                </div>

                <div class="card">
                    <div class="card-header">Volume de Apontamentos por Mês</div>
                    <div class="chart-container" style="height: 400px;"><canvas id="histogramChart"></canvas></div>
                </div>

                <div class="card">
                    <div class="card-header">Histórico de Taxa de Resolução (Mensal)</div>
                    <div class="chart-container" style="height: 400px;"><canvas id="monthlyResolutionRateChart"></canvas></div>
                </div>

                <div class="card">
                    <div class="card-header">Histórico de Apontamentos por Mês (Criados vs. Resolvidos)</div>
                    <div class="chart-container" style="height: 400px;"><canvas id="statusHistoryChart"></canvas></div>
                </div>

                <div class="card">
                    <div class="card-header">Análise Detalhada por Descrição</div>
                    <div class="filters" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); display: grid;">
                        <div class="filter-group"><label for="groupname-filter">Groupname</label><select id="groupname-filter"><option value="all">Todos</option></select></div>
                        <div class="filter-group"><label for="categoria-filter">Categoria</label><select id="categoria-filter"><option value="all">Todas</option></select></div>
                        <div class="filter-group"><label for="tipo-filter">Tipo</label><select id="tipo-filter"><option value="all">Todos</option></select></div>
                        <div class="filter-group"><label for="descricao-filter">Descrição (Defeito)</label><select id="descricao-filter"><option value="all">Todas</option></select></div>
                    </div>
                    <div class="chart-container" style="height: 500px;"><canvas id="detailsChart"></canvas></div>
                </div>

                <div class="card">
                    <div class="card-header">Mapa de Calor: Concentração por Categoria/Mês</div>
                     <div class="filters" style="padding: 0; box-shadow: none; margin-bottom: 15px;">
                         <div class="filter-group" style="min-width: 150px; max-width: 200px;">
                             <label for="heatmap-year-filter">Ano do Mapa de Calor</label>
                             <select id="heatmap-year-filter"><option value="all">Todos</option></select>
                         </div>
                     </div>
                    <div class="chart-container" style="height: 500px;"><canvas id="heatmapChart"></canvas></div>
                    <div id="heatmap-legend" class="mt-4 flex items-center justify-center space-x-2 text-sm text-gray-600"></div>
                </div>
            </div>

            <div id="eficiencia" class="tab-content" style="display: none;">
                <div class="card">
                    <div class="card-header">Desempenho de Resolução por Categoria</div>
                    <div class="card-subheader">(Eixo X = Tempo Médio de Resolução, Eixo Y = Volume de Apontamentos)</div>
                     <div class="chart-container" style="height: 450px;"><canvas id="resolutionScatterChart"></canvas></div>
                     <div id="scatter-legend-table"></div>
                     <div id="inference-section"></div>
                </div>
                 <div class="card mt-6">
                    <div class="card-header">Cumprimento de SLA por Categoria</div>
                     <div class="chart-container" style="height: 400px;"><canvas id="slaByCategoryChart"></canvas></div>
                </div>
            </div>

            <div id="localizacao" class="tab-content" style="display: none;">
                <div class="filters">
                    <div class="filter-group">
                        <label for="grouping-filter">Filtrar por Agrupamento (Torre/Setor)</label>
                        <select id="grouping-filter">
                            <option value="all">Todos</option>
                        </select>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">Ranking de Locais por Volume de Apontamentos</div>
                    <div class="card-subheader">(Top 15 locais com maior incidência no agrupamento selecionado)</div>
                    <div class="chart-container" style="height: 500px;"><canvas id="locationRankingChart"></canvas></div>
                </div>
                
                <div class="card">
                    <div class="card-header">Mapa de Calor: Categoria vs. Local</div>
                    <div class="card-subheader">(Concentração de tipos de problema por local no agrupamento selecionado)</div>
                    <div class="chart-container" style="height: 600px;"><canvas id="locationCategoryHeatmap"></canvas></div>
                </div>
            </div>
            </main>
    </div>

    <footer class="bg-white dark:bg-gray-800 shadow-inner py-6 text-center">
        <div class="container mx-auto">
            <p class="text-gray-600 mb-4">Carregue um arquivo <code class="bg-gray-200 p-1 rounded">.jsonl</code> para análise ou use o seletor de projeto.</p>
            <input type="file" id="json-file-input" accept=".jsonl,.txt,.json" style="display: none;" />
            <button class="bg-[--cor-primaria] hover:bg-blue-900 text-white font-bold py-2 px-4 rounded" onclick="document.getElementById('json-file-input').click()">Carregar Arquivo Manual</button>
            <p id="file-name" style="margin-top: 10px; font-size: 14px; color: #555;"></p>
        </div>
    </footer>

    <div id="modal-container">
        <div id="modal-content">
            <h3 id="modal-title"></h3>
            <div id="modal-body"></div>
            <button id="modal-close-btn">Fechar</button>
        </div>
    </div>

    <div id="drag-drop-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(1, 69, 92, 0.85); z-index: 9999; display: none; justify-content: center; align-items: center; pointer-events: none;">
        <div style="border: 3px dashed var(--cor-secundaria); border-radius: 15px; padding: 40px 60px; text-align: center;">
            <h2 style="color: white; font-size: 2em; font-weight: bold;">Solte o arquivo .jsonl aqui</h2>
            <p style="color: var(--light-color); font-size: 1.1em;">O processamento será iniciado automaticamente.</p>
        </div>
    </div>


    <script>
        // ### VARIÁVEIS GLOBAIS E DE ESTADO ###
        let allData = []; // Armazena todos os dados brutos processados do arquivo
        let currentFinalData = []; // Armazena os dados filtrados atualmente exibidos nos gráficos
        let histogramChart, detailsChart, heatmapChart, slaByCategoryChart, monthlyResolutionRateChart, resolutionScatterChart, statusHistoryChart;
        let locationRankingChart, locationCategoryHeatmap; // groupingVolumeChart REMOVIDO
        // Regras de SLA (Service Level Agreement) por prioridade
        const SLA_RULES = { 1: 3, 2: 7, 3: 15, 4: 30 }; // Prioridade: Dias

        // NOVO: Mapeamento de Nome do Projeto para Nome do Arquivo
        const PROJECT_FILES = {
            "Hotel": "./Hotel.jsonl",
            "Centro Medico": "./Centro medico.jsonl",
            "Ensino": "./Ensino.jsonl",
            "Residencial": "./Residencial.jsonl",
            "Embasamento": "./Embasamento.jsonl"
        };

        // ### PROCESSAMENTO E NORMALIZAÇÃO DE DADOS ###

        const processAndNormalizeData = (rawData) => {
             return rawData.map(item => {
                 // Corrigir possível caractere inválido no início de algumas chaves (ex: "﻿SnagID")
                 const cleanItem = {};
                 for (const key in item) {
                     if (Object.hasOwnProperty.call(item, key)) {
                         const cleanKey = key.replace(/^\uFEFF/, ''); // Remove BOM character if present
                         cleanItem[cleanKey] = item[key];
                     }
                 }
                 item = cleanItem; // Usa o item limpo

                if (!item.SnagID) return null;
                // Ajuste para formatos de data variados (ISO e DD/MM/YYYY HH:MM:SS)
                let spottedDate = null;
                if (item.Spotted) {
                    if (item.Spotted.includes('T')) { // Formato ISO 8601
                        spottedDate = item.Spotted.split('T')[0];
                    } else if (item.Spotted.includes('/')) { // Formato DD/MM/YYYY HH:MM:SS
                        const parts = item.Spotted.split(' ')[0].split('/');
                        if (parts.length === 3) {
                             // Formato DD/MM/YYYY -> YYYY-MM-DD
                             spottedDate = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                        }
                    }
                }

                // Ajuste para Data alteração (pode ter T ou não)
                let fixDate = null;
                let lastChangedDate = null;
                 const changeDateField = item['Data alteração'] || item['LastChanged']; // Usar LastChanged se Data alteração não existir
                 if(changeDateField) {
                     if (changeDateField.includes('T')) { // Formato ISO
                         fixDate = changeDateField.split('T')[0];
                         lastChangedDate = fixDate;
                     } else if (changeDateField.includes('/')) { // Formato DD/MM/YYYY HH:MM:SS
                        const parts = changeDateField.split(' ')[0].split('/');
                         if (parts.length === 3) {
                              fixDate = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                              lastChangedDate = fixDate;
                         }
                     }
                 }


                let finalStatus = item.Status;
                if (item.FixStatus?.toLowerCase() === 'signedoff') finalStatus = 'SignedOff';
                if (item.FixStatus?.toLowerCase() === 'notadefect') finalStatus = 'NotADefect';
                let daysToResolve = null;
                if ((finalStatus === 'Closed' || finalStatus === 'SignedOff') && spottedDate && fixDate) {
                    try {
                        const start = new Date(spottedDate);
                        const end = new Date(fixDate);
                         if (!isNaN(start) && !isNaN(end) && end >= start) { // Adicionado check end >= start
                            daysToResolve = (end - start) / (1000 * 60 * 60 * 24);
                        } else {
                             // console.warn(`Datas inválidas ou data final anterior à inicial para ${item.SnagID}: Spotted=${spottedDate}, Fix=${fixDate}`);
                         }
                    } catch (e) {
                         // console.error(`Erro ao calcular dias para resolver ${item.SnagID}:`, e);
                    }
                }
                const sla = SLA_RULES[item.Priority];
                const withinSla = daysToResolve !== null && sla !== undefined ? daysToResolve <= sla : null;

                const location = item.Location || "Não definido";
                let agrupamento = "N/A";
                let tipoAgrupamento = "Outro";
                let pavimento = location;

                // Tenta extrair Agrupamento/Pavimento (mantém a lógica original)
                const match = location.match(/^(T|S)0?([1-5])_?/i);

                if (match) {
                    const typeChar = match[1].toUpperCase();
                    const number = match[2];

                    if (typeChar === 'T') {
                        tipoAgrupamento = "Torre";
                        agrupamento = `Torre 0${number}`;
                    } else if (typeChar === 'S') {
                        tipoAgrupamento = "Setor";
                        agrupamento = `Setor 0${number}`;
                    }
                    pavimento = location.substring(match[0].length).trim();
                } else {
                     // Adicionar lógica para tentar extrair de formatos como "Est Pav XX" ou "Subsolo XX"
                    const pavMatch = location.match(/^(?:Est\s)?(?:Pav|Subsolo)\s(\d+)/i);
                     if (pavMatch && pavMatch[1]) {
                         // Não define agrupamento Torre/Setor, mas extrai pavimento
                         pavimento = location; // Ou poderia tentar normalizar, mas manter original é mais seguro
                     } else {
                         // Se não corresponder a T/S nem Pav/Subsolo, usa a localização inteira como pavimento
                         pavimento = location;
                     }
                }


                return {
                    id: item.SnagID,
                    responsavel: item.Fullname || "Não atribuído",
                    data: spottedDate, // Já está em YYYY-MM-DD ou null
                    lastChangedDate: lastChangedDate, // Já está em YYYY-MM-DD ou null
                    tipo: item.Description || "Não definido",
                    categoria: item.Category || "Não definida",
                    descricao: item.Defect || "Não definido",
                    situacao: finalStatus || "Não definida",
                    groupname: item.Groupname || "Não definido",
                    priority: item.Priority,
                    daysToResolve: daysToResolve,
                    withinSla: withinSla,
                    Location: location,
                    Agrupamento: agrupamento,
                    TipoAgrupamento: tipoAgrupamento,
                    Pavimento: pavimento
                };
             }).filter(item => item !== null && item.data); // MODIFICADO: Filtrar também itens sem data (spottedDate) válida
        };


        const processDataInChunks = async (rawData, onProgress) => {
            const chunkSize = 1000;
            let processedData = [];
            for (let i = 0; i < rawData.length; i += chunkSize) {
                const chunk = rawData.slice(i, i + chunkSize);

                const processedChunk = processAndNormalizeData(chunk);
                processedData = processedData.concat(processedChunk);

                const progress = Math.round(((i + chunk.length) / rawData.length) * 100);
                onProgress(progress);

                await new Promise(resolve => setTimeout(resolve, 0));
            }
            return processedData;
        };

        const getUniqueRecords = (data) => {
             const seenIds = new Set();
            return data.filter(item => {
                if (!item || !item.id) return false; // Adiciona checagem extra
                if (seenIds.has(item.id)) return false;
                seenIds.add(item.id);
                return true;
            });
        };

        /**
         * Processa o conteúdo de texto de um arquivo.
         * @param {string} content - Conteúdo do arquivo JSONL.
         * @param {string} fileDescription - Descrição do arquivo/projeto (ex: "Hotel").
         */
        const processContent = async (content, fileDescription) => {
             const loadingContainer = document.getElementById('loading-container');
             const statusText = document.getElementById('loading-status');
             const progressBar = document.getElementById('progress-bar');
             const dashboardContent = document.getElementById('dashboard-content');
             const initialMessage = document.getElementById('initial-message');

            try {
                statusText.textContent = 'Leitura concluída. Processando dados...';
                progressBar.style.width = '50%';
                initialMessage.style.display = 'none'; // Esconde msg inicial

                 // Limpa dados e gráficos ANTES de processar novos dados
                 clearDashboardState();

                 let rawData;
                 try {
                     rawData = content.split('\n')
                                      .filter(line => line.trim().length > 0) // Ignora linhas vazias
                                      .map(line => JSON.parse(line.replace(/:\s*NaN/g, ': null')));
                 } catch (parseErr) {
                      console.error("Erro de parse JSONL:", parseErr, "Linha problemática pode estar próxima.");
                      // Tentar encontrar a linha problemática (simplificado)
                      content.split('\n').forEach((line, index) => {
                          if (line.trim().length > 0) { // Only try to parse non-empty lines
                              try {
                                  JSON.parse(line.replace(/:\s*NaN/g, ': null'));
                              } catch (e) {
                                  console.error(`Erro ao parsear linha ${index + 1}: ${line.substring(0, 100)}...`, e);
                              }
                          }
                      });
                      throw new Error(`Formato JSON inválido no arquivo ${fileDescription}. Verifique o console para detalhes.`);
                 }


                // Processa os dados brutos em blocos
                allData = await processDataInChunks(rawData, (progress) => {
                    const totalProgress = 50 + (progress / 2);
                    statusText.textContent = `Processando dados de ${fileDescription}... ${progress}%`;
                    progressBar.style.width = `${totalProgress}%`;
                });

                // Ordena os dados pela data 'Spotted' (mais antigos primeiro) - pode ajudar em gráficos de histórico
                allData.sort((a, b) => {
                     if (!a.data) return 1; // Coloca itens sem data no final
                     if (!b.data) return -1;
                     try {
                        const dateA = new Date(a.data);
                        const dateB = new Date(b.data);
                        if (isNaN(dateA)) return 1;
                        if (isNaN(dateB)) return -1;
                        return dateA - dateB;
                     } catch (e) {
                        return 0; // Mantém a ordem original em caso de erro de data
                     }
                 });

                console.log(`Dados processados e ordenados (${allData.length} registros) para ${fileDescription}`);

                if (allData.length === 0) {
                    showError(`O arquivo ${fileDescription} não contém dados de apontamentos válidos ou com data.`);
                    loadingContainer.style.display = 'none';
                    return;
                }

                statusText.textContent = 'Gerando gráficos...';
                document.getElementById('file-name').textContent = `Projeto: ${fileDescription}`;
                populateGlobalFilters(); // Popula filtros de Ano/Mês
                populateHeatmapYearFilter(allData);
                runUpdate(); // Gera os gráficos com base nos dados carregados e filtros padrão

                loadingContainer.style.display = 'none';
                dashboardContent.style.display = 'block';

            } catch (err) {
                console.error(`Erro detalhado ao processar ${fileDescription}:`, err);
                showError(`Erro ao processar os dados do projeto ${fileDescription}. Detalhe: ${err.message}`);
                loadingContainer.style.display = 'none';
                dashboardContent.style.display = 'none'; // Garante que o dashboard não seja exibido
                initialMessage.style.display = 'block'; // Mostra msg inicial em caso de erro
                initialMessage.textContent = `Falha ao carregar dados do projeto ${fileDescription}. Tente outro projeto ou carregue um arquivo.`
            }
        };


        /**
         * Limpa o estado atual do dashboard (gráficos, dados, filtros).
         */
         function clearDashboardState() {
             allData = [];
             currentFinalData = [];

             // Destroi gráficos existentes se eles existirem
             const charts = [
                 histogramChart, detailsChart, heatmapChart, slaByCategoryChart,
                 monthlyResolutionRateChart, resolutionScatterChart, statusHistoryChart,
                 locationRankingChart, locationCategoryHeatmap // groupingVolumeChart REMOVIDO
             ];
             charts.forEach(chart => {
                 if (chart && typeof chart.destroy === 'function') {
                     try {
                         chart.destroy();
                     } catch (e) {
                         console.error("Erro ao destruir gráfico:", e);
                     }
                 }
             });
              // Limpa as variáveis para garantir que não sejam reutilizadas acidentalmente
             histogramChart = detailsChart = heatmapChart = slaByCategoryChart = monthlyResolutionRateChart = resolutionScatterChart = statusHistoryChart = locationRankingChart = locationCategoryHeatmap = null; // groupingVolumeChart REMOVIDO


             // Limpa legendas e inferências
             document.getElementById('scatter-legend-table').innerHTML = '';
             document.getElementById('inference-section').innerHTML = '';
             document.getElementById('heatmap-legend').innerHTML = '';

             // Reseta filtros principais para 'Todos'
             const filterIdsToReset = ['year-filter', 'month-filter', 'groupname-filter', 'categoria-filter', 'tipo-filter', 'descricao-filter', 'heatmap-year-filter', 'grouping-filter'];
             filterIdsToReset.forEach(id => {
                 const select = document.getElementById(id);
                 if (select) {
                     // Limpa opções antigas (exceto a primeira 'Todos')
                     while (select.options.length > 1) {
                         select.remove(1);
                     }
                     select.value = 'all'; // Define o valor para 'Todos'
                 }
             });
              document.getElementById('spotted-filter').value = ''; // Limpa filtro de data específica

             // Limpa KPIs
             document.getElementById('total-records').textContent = '0';
             document.getElementById('open-records').textContent = '0';
             document.getElementById('closed-records').textContent = '0';
             document.getElementById('signed-off-records').textContent = '0';
             document.getElementById('not-accepted-records').textContent = '0';
             document.getElementById('resolution-rate').textContent = '0%';

             // Garante que a primeira aba esteja ativa visualmente (se aplicável)
             openTab({ currentTarget: document.querySelector('.tab-link') }, 'visaoGeral');
         }

        /**
         * NOVA FUNÇÃO: Carrega e processa dados de um projeto selecionado.
         * @param {string} projectName - O nome do projeto (chave do objeto PROJECT_FILES).
         */
        const loadProjectData = async (projectName) => {
            const fileName = PROJECT_FILES[projectName];
            if (!fileName) {
                showError(`Arquivo de dados não definido para o projeto "${projectName}".`);
                return;
            }

            const loadingContainer = document.getElementById('loading-container');
            const statusText = document.getElementById('loading-status');
            const progressBar = document.getElementById('progress-bar');
            const dashboardContent = document.getElementById('dashboard-content');
            const initialMessage = document.getElementById('initial-message');

            // Exibir carregamento e ocultar conteúdo/erros
             dashboardContent.style.display = 'none';
             initialMessage.style.display = 'none';
             document.getElementById('error-message').style.display = 'none';
             statusText.textContent = `Carregando dados do projeto ${projectName}...`;
             progressBar.style.width = '5%';
             loadingContainer.style.display = 'block';

             // Limpa o estado antes de carregar (IMPORTANTE)
             clearDashboardState();


            try {
                // Busca o arquivo JSONL do projeto selecionado
                statusText.textContent = `Buscando arquivo ${fileName}...`;
                const response = await fetch(fileName);
                progressBar.style.width = '25%';

                if (!response.ok) {
                    throw new Error(`Falha ao buscar ${fileName} (HTTP ${response.status})`);
                }

                statusText.textContent = `Lendo arquivo ${fileName}...`;
                const content = await response.text();
                progressBar.style.width = '45%';

                // Processa o conteúdo usando a função existente
                await processContent(content, projectName); // Passa o NOME do projeto como descrição

            } catch (err) {
                 console.error(`Falha ao carregar dados do projeto ${projectName}:`, err);
                 showError(`Não foi possível carregar os dados para o projeto ${projectName}. Detalhe: ${err.message}. Verifique se o arquivo ${fileName} existe e está acessível.`);
                 loadingContainer.style.display = 'none';
                 initialMessage.style.display = 'block'; // Mostra msg inicial em caso de erro
                 initialMessage.textContent = `Falha ao carregar dados do projeto ${projectName}. Tente outro projeto ou carregue um arquivo.`
            }
        };


        /**
         * Processa um arquivo carregado manualmente pelo usuário. (Mantida para upload manual)
         */
        const processFile = async (file) => {
             if (!file) return;

            if (!file.name.endsWith('.jsonl') && !file.name.endsWith('.txt') && !file.name.endsWith('.json')) {
                showError('Por favor, carregue um arquivo válido (.jsonl, .json ou .txt).');
                return;
            }

            const loadingContainer = document.getElementById('loading-container');
            const statusText = document.getElementById('loading-status');
            const progressBar = document.getElementById('progress-bar');
            const dashboardContent = document.getElementById('dashboard-content');
            const initialMessage = document.getElementById('initial-message');


            // Exibe carregamento, oculta conteúdo
            initialMessage.style.display = 'none';
            dashboardContent.style.display = 'none';
            document.getElementById('error-message').style.display = 'none';
            statusText.textContent = 'Lendo arquivo manual...';
            progressBar.style.width = '0%';
            loadingContainer.style.display = 'block';

            // Limpa estado anterior ANTES de ler o novo arquivo
            clearDashboardState();

            document.getElementById('file-name').textContent = `Arquivo Manual: ${file.name}`;


            const reader = new FileReader();

            reader.onprogress = (event) => {
                if (event.lengthComputable) {
                    const percentage = Math.round((event.loaded / event.total) * 45); // Ajustado para 45%
                    statusText.textContent = `Lendo arquivo... ${Math.round(percentage / 0.45)}%`;
                    progressBar.style.width = `${percentage}%`;
                }
            };

            reader.onload = async (e) => {
                // Passa o nome do arquivo único para processContent
                 // Usa o nome do arquivo como descrição para uploads manuais
                await processContent(e.target.result, `Manual: ${file.name}`);
            };

            reader.onerror = () => {
                showError('Não foi possível ler o arquivo carregado.');
                loadingContainer.style.display = 'none';
                initialMessage.style.display = 'block'; // Mostra msg inicial em caso de erro
                initialMessage.textContent = 'Falha ao ler o arquivo. Tente novamente ou selecione um projeto.'
            };

            reader.readAsText(file);
        };

        // --- MANIPULADOR DE UPLOAD E ATUALIZAÇÃO ---

        const handleFileUpload = (event) => {
             const file = event.target.files[0];
            processFile(file); // Chama a função mantida para upload manual
        };

        const runUpdate = () => {
             if (allData.length === 0) {
                 console.warn("runUpdate chamado sem dados em allData.");
                 // Poderia opcionalmente limpar a tela aqui ou mostrar uma mensagem
                 return;
             }

             // Lógica de filtragem existente...
            const selectedSpottedDate = document.getElementById('spotted-filter').value;
            const selectedYear = document.getElementById('year-filter').value;
            const selectedMonth = document.getElementById('month-filter').value;
            let baseFilteredData = allData;
            if (selectedSpottedDate) {
                baseFilteredData = baseFilteredData.filter(d => d.data === selectedSpottedDate);
            }
            if (selectedYear !== 'all') {
                const yearNumber = parseInt(selectedYear, 10);
                const today = new Date();
                const currentYear = today.getFullYear();
                today.setHours(0, 0, 0, 0);
                baseFilteredData = baseFilteredData.filter(d => {
                    if (!d.data) return false;
                     try {
                         const recordDate = new Date(d.data);
                         if (isNaN(recordDate.getTime())) return false; // Ignora datas inválidas
                         if (recordDate.getFullYear() !== yearNumber) return false;
                         // Não filtra datas futuras se o ano selecionado for anterior ao atual
                         if (yearNumber === currentYear && recordDate > today) return false;
                         return true;
                     } catch (e) { return false; } // Ignora erros de data
                });
            }
            if (selectedMonth !== 'all') {
                const monthNumber = parseInt(selectedMonth, 10);
                baseFilteredData = baseFilteredData.filter(d => {
                    if (!d.data) return false;
                     try {
                         const recordDate = new Date(d.data);
                         if (isNaN(recordDate.getTime())) return false;
                         return recordDate.getMonth() === monthNumber;
                     } catch (e) { return false; }
                });
            }

            const uniqueBaseFilteredData = getUniqueRecords(baseFilteredData);

            // Atualiza filtros de detalhe ANTES de aplicar seus valores
            updateDetailFilters(uniqueBaseFilteredData);

            // Aplica filtros de detalhe...
            const selectedGroupname = document.getElementById('groupname-filter').value;
            const selectedCategoria = document.getElementById('categoria-filter').value;
            const selectedTipo = document.getElementById('tipo-filter').value;
            const selectedDescricao = document.getElementById('descricao-filter').value;
            let finalFilteredData = uniqueBaseFilteredData;
            if (selectedGroupname !== 'all') finalFilteredData = finalFilteredData.filter(d => d.groupname === selectedGroupname);
            if (selectedCategoria !== 'all') finalFilteredData = finalFilteredData.filter(d => d.categoria === selectedCategoria);
            if (selectedTipo !== 'all') finalFilteredData = finalFilteredData.filter(d => d.tipo === selectedTipo);
            if (selectedDescricao !== 'all') finalFilteredData = finalFilteredData.filter(d => d.descricao === selectedDescricao);

            currentFinalData = finalFilteredData; // Atualiza os dados finais filtrados

            // Atualiza KPIs e Gráficos...
             updateKPIs(uniqueBaseFilteredData); // KPIs baseados nos filtros de data/ano/mês
             updateHistogramChart(uniqueBaseFilteredData);
             updateDetailsChart(finalFilteredData); // Gráfico de detalhes usa todos os filtros
             updateHeatmapChart(uniqueBaseFilteredData); // Heatmap usa filtros de data/ano/mês
             updateMonthlyResolutionRateChart(uniqueBaseFilteredData);

             // Histórico usa todos os dados (ou filtrados por ano/mês globalmente)
             updateStatusHistoryChart(getUniqueRecords(allData), selectedYear, selectedMonth); // Usar allData aqui para histórico completo

             // Gráficos de eficiência usam todos os filtros
             updateResolutionScatterChart(finalFilteredData);
             updateSlaByCategoryChart(finalFilteredData);

             // Popula filtro de agrupamento e atualiza gráficos de localização
             populateGroupingFilter(finalFilteredData); // Baseado nos dados filtrados
             // updateGroupingVolumeChart(finalFilteredData); // REMOVIDA CHAMADA

            const selectedGrouping = document.getElementById('grouping-filter').value;
            let locationFilteredData = finalFilteredData;
            if(selectedGrouping !== 'all') {
                locationFilteredData = finalFilteredData.filter(d => d.Agrupamento === selectedGrouping);
            }

             updateLocationRankingChart(locationFilteredData); // Usa filtro de agrupamento
             updateLocationCategoryHeatmap(locationFilteredData); // Usa filtro de agrupamento

             console.log("Dashboard atualizado.");
        };

        // --- FUNÇÕES DE ATUALIZAÇÃO DE GRÁFICOS E FILTROS ---

         const updateDetailFilters = (data) => {
             // Esta função já depende dos valores atuais dos filtros, o que é bom
             const groupnameSelect = document.getElementById('groupname-filter');
             const categoriaSelect = document.getElementById('categoria-filter');
             const tipoSelect = document.getElementById('tipo-filter');
             const descricaoSelect = document.getElementById('descricao-filter');

             // Guarda os valores selecionados atualmente
             const currentGroupname = groupnameSelect.value;
             const currentCategoria = categoriaSelect.value;
             const currentTipo = tipoSelect.value;
             const currentDescricao = descricaoSelect.value;

             // Popula Groupname
             const groupnamesUnicos = [...new Set(data.map(item => item.groupname))].filter(Boolean);
             populateDropdown('groupname-filter', groupnamesUnicos, currentGroupname);

             // Filtra para Categoria (baseado no groupname selecionado ou todos)
             const dataFiltradaPorGrupo = currentGroupname === 'all' ? data : data.filter(d => d.groupname === currentGroupname);
             const categoriasUnicas = [...new Set(dataFiltradaPorGrupo.map(item => item.categoria))].filter(Boolean);
             populateDropdown('categoria-filter', categoriasUnicas, currentCategoria);

             // Filtra para Tipo (baseado no groupname e categoria selecionados ou todos)
             const dataFiltradaPorCategoria = currentCategoria === 'all' ? dataFiltradaPorGrupo : dataFiltradaPorGrupo.filter(d => d.categoria === currentCategoria);
             const tiposUnicos = [...new Set(dataFiltradaPorCategoria.map(item => item.tipo))].filter(Boolean);
             populateDropdown('tipo-filter', tiposUnicos, currentTipo);

             // Filtra para Descrição (baseado em groupname, categoria e tipo selecionados ou todos)
             const dataFiltradaPorTipo = currentTipo === 'all' ? dataFiltradaPorCategoria : dataFiltradaPorCategoria.filter(d => d.tipo === currentTipo);
             const descricoesUnicas = [...new Set(dataFiltradaPorTipo.map(item => item.descricao))].filter(Boolean);
             populateDropdown('descricao-filter', descricoesUnicas, currentDescricao);
         };

        // ****** FUNÇÃO CORRIGIDA ******
        const populateDropdown = (elementId, options, selectedValue = 'all') => {
            const select = document.getElementById(elementId);
            if (!select) return; // Segurança

            const currentValue = select.value; // Guarda o valor atual ANTES de limpar

            // Limpa opções existentes (exceto a primeira "Todos")
            while (select.options.length > 1) {
                select.remove(1);
            }

            // Adiciona novas opções ordenadas, convertendo para string ANTES de comparar
            options.sort((a, b) => {
                // Converte null/undefined para strings vazias e números para strings
                const strA = String(a === null || a === undefined ? '' : a);
                const strB = String(b === null || b === undefined ? '' : b);
                return strA.localeCompare(strB); // Agora compara strings com segurança
            }).forEach(optionValue => {
                 if(optionValue !== null && optionValue !== undefined) { // Não adicionar opções nulas ou undefined explicitamente
                    // Cria a opção. Converte para string para o texto visível se for número (ex: ano)
                    select.add(new Option(String(optionValue), optionValue));
                 }
            });

            // Tenta restaurar o valor selecionado anteriormente, se ainda existir
            // Se não existir (ou era 'all'), mantém 'all'
            select.value = [...select.options].some(opt => opt.value === String(currentValue)) ? String(currentValue) : 'all'; // Compara como string também
        };
        // ****** FIM DA CORREÇÃO ******

        const populateGlobalFilters = () => {
             // Popula apenas Ano, Mês é fixo
            const years = [...new Set(allData.map(item => item.data ? new Date(item.data).getFullYear() : null))]
                            .filter(Boolean) // Remove nulos/undefined
                            .sort((a, b) => b - a); // Ordena do mais recente para o mais antigo
            populateDropdown('year-filter', years);
            // Resetar mês para 'Todos' ao carregar novos dados
            document.getElementById('month-filter').value = 'all';
        };

        const populateHeatmapYearFilter = (data) => {
            const years = [...new Set(data.map(item => item.data ? new Date(item.data).getFullYear() : null))]
                            .filter(Boolean)
                            .sort((a, b) => b - a);
            populateDropdown('heatmap-year-filter', years);
             // Mantém o valor selecionado se possível, senão volta para 'all'
             const currentHeatmapYear = document.getElementById('heatmap-year-filter').value;
             if (!years.map(String).includes(currentHeatmapYear)) {
                 document.getElementById('heatmap-year-filter').value = 'all';
             }
        };

        const populateGroupingFilter = (data) => {
            const groupings = [...new Set(data.map(item => item.Agrupamento))]
                                .filter(g => g && g !== 'N/A') // Filtra nulos/undefined e 'N/A'
                                .sort(); // Ordena alfabeticamente
            populateDropdown('grouping-filter', groupings);
             // Mantém o valor selecionado se possível, senão volta para 'all'
             const currentGrouping = document.getElementById('grouping-filter').value;
             if (!groupings.includes(currentGrouping)) {
                 document.getElementById('grouping-filter').value = 'all';
             }
        };


        const updateKPIs = (data) => {
            const totalCount = data.length;
            document.getElementById('total-records').textContent = totalCount;
            document.getElementById('open-records').textContent = data.filter(d => d.situacao?.toLowerCase() === 'open').length;
            const closedCount = data.filter(d => d.situacao?.toLowerCase() === 'closed').length;
            const signedOffCount = data.filter(d => d.situacao?.toLowerCase() === 'signedoff').length;
            document.getElementById('closed-records').textContent = closedCount;
            document.getElementById('signed-off-records').textContent = signedOffCount;
            document.getElementById('not-accepted-records').textContent = data.filter(d => d.situacao?.toLowerCase() === 'notadefect').length;
            const resolvedCount = closedCount + signedOffCount;
            const resolutionRate = totalCount > 0 ? ((resolvedCount / totalCount) * 100).toFixed(1) : 0;
            document.getElementById('resolution-rate').textContent = `${resolutionRate}%`;
        };

        // --- Funções de Gráficos (updateHistogramChart, etc.) ---
        const updateHistogramChart = (data) => {
            const ctx = document.getElementById('histogramChart').getContext('2d');
            const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            const monthlyCounts = Array(12).fill(0);
            data.forEach(item => {
                if (item.data) {
                    try {
                        const date = new Date(item.data);
                        if(!isNaN(date)) {
                             const month = date.getMonth();
                             if (month >= 0 && month < 12) monthlyCounts[month]++;
                        }
                    } catch(e){}
                }
            });
            if (histogramChart) histogramChart.destroy();
            histogramChart = new Chart(ctx, { type: 'bar', data: { labels: months, datasets: [{ label: 'Apontamentos', data: monthlyCounts, backgroundColor: 'rgba(1, 70, 92, 0.7)', borderColor: 'rgba(1, 70, 92, 1)', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }, plugins: { legend: { display: false } } } });
        };

        const updateMonthlyResolutionRateChart = (data) => {
            const ctx = document.getElementById('monthlyResolutionRateChart').getContext('2d');
            const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            const monthlyTotals = Array(12).fill(0);
            const monthlyResolved = Array(12).fill(0);
            data.forEach(item => {
                if (item.data) {
                     try {
                         const date = new Date(item.data);
                         if(!isNaN(date)) {
                             const month = date.getMonth();
                             if (month >= 0 && month < 12) {
                                 monthlyTotals[month]++;
                                 if (['closed', 'signedoff'].includes(item.situacao?.toLowerCase())) {
                                     monthlyResolved[month]++;
                                 }
                             }
                         }
                     } catch(e) {}
                }
            });
            const resolutionRates = monthlyTotals.map((total, index) => total > 0 ? (monthlyResolved[index] / total) * 100 : 0);
            if (monthlyResolutionRateChart) monthlyResolutionRateChart.destroy();
            monthlyResolutionRateChart = new Chart(ctx, { type: 'line', data: { labels: months, datasets: [{ label: 'Taxa de Resolução', data: resolutionRates, backgroundColor: 'rgba(159, 196, 25, 0.2)', borderColor: 'rgba(159, 196, 25, 1)', borderWidth: 2, fill: true, tension: 0.3 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: 100, ticks: { callback: (value) => `${value}%` } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (context) => ` Taxa: ${context.raw.toFixed(2)}%` } } } } });
        };

        const updateStatusHistoryChart = (data, selectedYear, selectedMonth) => {
            const ctx = document.getElementById('statusHistoryChart').getContext('2d');
            const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];

            const today = new Date();
            today.setHours(23, 59, 59, 999);

            const monthlyCreated = Array(12).fill(0);
            data.forEach(item => {
                if (item.data) {
                    try {
                        const recordDate = new Date(item.data);
                        if (isNaN(recordDate.getTime()) || recordDate > today) return;

                        if (selectedYear !== 'all' && recordDate.getFullYear() != selectedYear) return;
                        // Correção: Se um mês específico for selecionado, só contar criações naquele mês
                        if (selectedMonth !== 'all' && recordDate.getMonth() != selectedMonth) return;

                        const monthIndex = recordDate.getMonth();
                         if (monthIndex >= 0 && monthIndex < 12) { // Adicionado check de segurança
                            monthlyCreated[monthIndex]++;
                         }
                    } catch (e) {}
                }
            });

            const monthlyResolved = Array(12).fill(0);
            data.forEach(item => {
                 // Usar lastChangedDate para data de resolução
                 const status = item.situacao?.toLowerCase();
                 // Considerar Closed e SignedOff como resolvidos
                 if (item.lastChangedDate && (status === 'closed' || status === 'signedoff')) {
                     try {
                         const resolvedDate = new Date(item.lastChangedDate);
                         if (isNaN(resolvedDate.getTime()) || resolvedDate > today) return;

                         if (selectedYear !== 'all' && resolvedDate.getFullYear() != selectedYear) return;
                         // Correção: Se um mês específico for selecionado, só contar resoluções naquele mês
                         if (selectedMonth !== 'all' && resolvedDate.getMonth() != selectedMonth) return;

                         const monthIndex = resolvedDate.getMonth();
                         if (monthIndex >= 0 && monthIndex < 12) { // Adicionado check de segurança
                             monthlyResolved[monthIndex]++;
                         }
                     } catch (e) {}
                 }
            });


            if (statusHistoryChart) statusHistoryChart.destroy();

            statusHistoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: months,
                    datasets: [
                        {
                            label: 'Criados no Mês',
                            data: monthlyCreated,
                            backgroundColor: 'rgba(239, 68, 68, 0.7)', // Vermelho
                            borderColor: 'rgba(239, 68, 68, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Resolvidos no Mês',
                            data: monthlyResolved,
                            backgroundColor: 'rgba(159, 196, 25, 0.7)', // Verde
                            borderColor: 'rgba(159, 196, 25, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { stacked: false },
                        y: { beginAtZero: true, ticks: { precision: 0 }, stacked: false }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: { mode: 'index', intersect: false }
                    }
                }
            });
        };


        const updateDetailsChart = (data) => {
            const ctx = document.getElementById('detailsChart').getContext('2d');
            const descriptionCounts = data.reduce((acc, item) => {
                const key = item.descricao || "Não definido";
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});
            const sortedData = Object.entries(descriptionCounts).sort(([, a], [, b]) => b - a).slice(0, 15);
            const labels = sortedData.map(item => item[0]);
            const values = sortedData.map(item => item[1]);
            if (detailsChart) detailsChart.destroy();
            detailsChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Contagem', data: values, backgroundColor: 'rgba(159, 196, 25, 0.7)', borderColor: 'rgba(159, 196, 25, 1)', borderWidth: 1 }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, scales: { x: { beginAtZero: true, ticks: { precision: 0 } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: context => ` Apontamentos: ${context.raw}` } } } } });
        };

        const updateHeatmapChart = (data) => {
            const selectedYear = document.getElementById('heatmap-year-filter').value;
            let chartData = data;
            if (selectedYear !== 'all') {
                const yearNumber = parseInt(selectedYear, 10);
                const today = new Date();
                const currentYear = today.getFullYear();
                today.setHours(0, 0, 0, 0);
                chartData = data.filter(d => {
                    if (!d.data) return false;
                     try {
                         const recordDate = new Date(d.data);
                         if (isNaN(recordDate.getTime())) return false;
                         if (recordDate.getFullYear() !== yearNumber) return false;
                         if (yearNumber === currentYear && recordDate > today) return false;
                         return true;
                     } catch(e){ return false; }
                });
            }
            const ctx = document.getElementById('heatmapChart').getContext('2d');
            const monthLabels = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
            const categoryCounts = {};
            chartData.forEach(item => {
                if (item.data && item.categoria) {
                     try {
                         const date = new Date(item.data);
                         if (!isNaN(date)) {
                             const category = item.categoria;
                             const monthIndex = date.getMonth();
                             if (monthIndex >= 0 && monthIndex < 12) {
                                 const month = monthLabels[monthIndex];
                                 if (!categoryCounts[category]) categoryCounts[category] = {};
                                 categoryCounts[category][month] = (categoryCounts[category][month] || 0) + 1;
                             }
                         }
                     } catch (e) {}
                }
            });
            const heatmapData = [];
            let maxValue = 0;
            const categoryLabels = Object.keys(categoryCounts).sort();
            categoryLabels.forEach(category => {
                monthLabels.forEach(month => {
                    const value = categoryCounts[category]?.[month] || 0;
                    if (value > 0) heatmapData.push({ x: month, y: category, v: value });
                    if (value > maxValue) maxValue = value;
                });
            });

             if (heatmapChart) {
                 try { heatmapChart.destroy(); } catch(e) {}
             }
             if (categoryLabels.length === 0 || heatmapData.length === 0) {
                  // Limpa área do gráfico se não houver dados
                  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                  document.getElementById('heatmap-legend').innerHTML = ''; // Limpa legenda
                  heatmapChart = null; // Garante que a variável esteja limpa
                  return; // Sai da função
             }


            heatmapChart = new Chart(ctx, { type: 'matrix', data: { datasets: [{ label: 'Apontamentos', data: heatmapData, backgroundColor: (context) => { const value = context.dataset.data[context.dataIndex]?.v; if (!value) return 'rgba(245, 245, 245, 0.5)'; const alpha = value / maxValue; return `rgba(1, 70, 92, ${alpha})`; }, borderColor: 'white', borderWidth: 1, width: ({ chart }) => (chart.chartArea || {}).width / monthLabels.length - 1, height: ({ chart }) => (chart.chartArea || {}).height / categoryLabels.length - 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'category', labels: monthLabels }, y: { type: 'category', labels: categoryLabels, offset: true } }, plugins: { legend: { display: false }, tooltip: { callbacks: { title: () => '', label: (context) => { const v = context.dataset.data[context.dataIndex]; return v ? `${v.y} em ${v.x}: ${v.v} apontamentos` : ''; } } } } } });

            const legendContainer = document.getElementById('heatmap-legend');
            legendContainer.innerHTML = '';
            if (maxValue > 0) {
                const gradient = 'linear-gradient(to right, rgba(1, 70, 92, 0.05), rgba(1, 70, 92, 1))';
                legendContainer.innerHTML = `<span>Baixa (1)</span><div style="width: 150px; height: 20px; background: ${gradient}; border-radius: 5px; margin: 0 10px;"></div><span>Alta (${maxValue})</span>`;
            }
        };

         // --- Scatter Plot e Inferência ---
         const updateResolutionScatterChart = (data) => {
             const ctx = document.getElementById('resolutionScatterChart').getContext('2d');
             const legendContainer = document.getElementById('scatter-legend-table');
             const inferenceContainer = document.getElementById('inference-section');

             // Limpa o estado anterior
             if (resolutionScatterChart) {
                 try { resolutionScatterChart.destroy(); } catch(e) {}
                 resolutionScatterChart = null;
             }
             legendContainer.innerHTML = '';
             inferenceContainer.innerHTML = '';

             const statsByCategory = {};
             data.forEach(item => {
                 if (item.daysToResolve !== null && item.categoria) {
                     if (!statsByCategory[item.categoria]) {
                         statsByCategory[item.categoria] = { totalDays: 0, count: 0 };
                     }
                     statsByCategory[item.categoria].totalDays += item.daysToResolve;
                     statsByCategory[item.categoria].count++;
                 }
             });
             const scatterData = Object.keys(statsByCategory).map(category => {
                 const stats = statsByCategory[category];
                 const avgDays = stats.count > 0 ? (stats.totalDays / stats.count) : 0;
                 return { x: avgDays, y: stats.count, label: category };
             }).filter(d => d.y > 0); // Filtra categorias sem apontamentos resolvidos

             if (scatterData.length === 0) {
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Limpa o canvas
                 inferenceContainer.innerHTML = `<h3>Inferência Estatística e Plano de Ação</h3><p style="text-align:center; color: #555; padding: 20px 0;">Nenhum dado de resolução disponível para as categorias selecionadas.</p>`;
                 return; // Sai se não houver dados
             }

             // Lógica de cores e gráfico (igual à original)
             const avgDaysValues = scatterData.map(d => d.x);
             const minAvg = Math.min(...avgDaysValues);
             const maxAvg = Math.max(...avgDaysValues);
             const getColorForTime = (value) => {
                 if (maxAvg === minAvg || isNaN(minAvg) || isNaN(maxAvg)) return 'rgb(159, 196, 25)'; // Verde padrão se não houver variação ou valores inválidos
                 const ratio = (value - minAvg) / (maxAvg - minAvg);
                 // Interpolação de Cor: Verde (159, 196, 25) -> Azul Primário (1, 69, 92)
                 const r = Math.round(159 + (1 - 159) * ratio);
                 const g = Math.round(196 + (69 - 196) * ratio);
                 const b = Math.round(25 + (92 - 25) * ratio);
                 return `rgb(${r}, ${g}, ${b})`;
             };
             scatterData.forEach(d => d.color = getColorForTime(d.x));

             resolutionScatterChart = new Chart(ctx, {
                 type: 'scatter',
                 data: {
                     datasets: [{ data: scatterData, pointBackgroundColor: context => context.raw.color, pointRadius: 8, pointHoverRadius: 12, borderWidth: 0 }]
                 },
                 options: {
                     responsive: true,
                     maintainAspectRatio: false,
                     scales: {
                         x: { beginAtZero: true, title: { display: true, text: 'Tempo Médio de Resolução (Dias)'}},
                         y: { beginAtZero: true, title: { display: true, text: 'Volume de Apontamentos Resolvidos' }}
                     },
                     plugins: {
                         legend: { display: false },
                         tooltip: { callbacks: { label: (context) => { const point = context.raw; return point ? [`${point.label}`, `Volume: ${point.y}`, `Tempo Médio: ${point.x.toFixed(1)} dias`] : ''; } } }
                     }
                 }
             });

             // Geração da Legenda (Top 10)
             const top10Volume = [...scatterData].sort((a, b) => b.y - a.y).slice(0, 10);
             const top10Time = [...scatterData].sort((a, b) => b.x - a.x).slice(0, 10);
             const generateListHTML = (title, items, metric) => {
                 let listItems = items.map(item => `<li><div class="legend-color-box" style="background-color: ${item.color};"></div><div>${item.label} (${metric === 'volume' ? `${item.y} apont.` : `${item.x.toFixed(1)} dias`})</div></li>`).join('');
                 return `<div class="px-4"><h3>${title}</h3><ol>${listItems}</ol></div>`;
             };
             legendContainer.innerHTML = generateListHTML('Top 10 por Volume', top10Volume, 'volume') + generateListHTML('Top 10 por Tempo de Resolução', top10Time, 'time');

             // Lógica de Inferência (igual à original, mas com verificação de dados)
             if (scatterData.length < 2) {
                 inferenceContainer.innerHTML = `<h3>Inferência Estatística e Plano de Ação</h3><p style="text-align:center; color: #555; padding: 20px 0;">A análise de quadrantes requer a comparação entre múltiplas categorias. Com apenas ${scatterData.length} categoria(s) visível(is), não é possível gerar uma inferência comparativa.</p>`;
             } else {
                 const validAvgDaysValues = avgDaysValues.filter(v => !isNaN(v)); // Filtra NaN
                 const avgX = validAvgDaysValues.length > 0 ? validAvgDaysValues.reduce((a, b) => a + b, 0) / validAvgDaysValues.length : 0;
                 const validYValues = scatterData.map(d => d.y).filter(v => !isNaN(v));
                 const avgY = validYValues.length > 0 ? validYValues.reduce((a, b) => a + b, 0) / validYValues.length : 0;

                 const quadrants = {
                     criticos: scatterData.filter(d => d.x > avgX && d.y > avgY).sort((a,b) => b.y - a.y),
                     eficientes: scatterData.filter(d => d.x <= avgX && d.y > avgY).sort((a,b) => b.y - a.y),
                     ineficientes: scatterData.filter(d => d.x > avgX && d.y <= avgY).sort((a,b) => b.x - a.x)
                 };

                 const ICON_CRITICO = `<svg xmlns="http://www.w3.org/2000/svg" fill="var(--cor-alerta)" viewBox="0 0 24 24" stroke-width="1.5" stroke="white"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>`;
                 const ICON_EFICIENTE = `<svg xmlns="http://www.w3.org/2000/svg" fill="var(--cor-secundaria)" viewBox="0 0 24 24" stroke-width="1.5" stroke="white"><path stroke-linecap="round" stroke-linejoin="round" d="M15.59 14.37a6 6 0 01-5.84 7.38v-4.82m5.84-2.56a14.96 14.96 0 00-5.84-2.56m0 0a14.96 14.96 0 01-5.84-2.56m5.84 2.56v-4.82m0 0a6 6 0 00-5.84-7.38v4.82m5.84 2.56h4.82a6 6 0 01-7.38 5.84m0 0a6 6 0 00-7.38-5.84h4.82" /></svg>`;
                 const ICON_INEFICIENTE = `<svg xmlns="http://www.w3.org/2000/svg" fill="var(--cor-aviso)" viewBox="0 0 24 24" stroke-width="1.5" stroke="white"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;

                 const generateInferenceHTML = (title, description, categories, iconSvg, quadrantClass) => {
                     if (categories.length === 0) return '';
                     const items = categories.map(cat => `<span class="inference-category-tag" onclick="showDefectDetails('${cat.label.replace(/'/g, "\\'")}')">${cat.label}</span>`).join('');
                     return `
                         <div class="inference-card ${quadrantClass}">
                             <div class="inference-card-header">
                                 ${iconSvg}
                                 <h4>${title}</h4>
                             </div>
                             <p>${description}</p>
                             <div class="inference-tag-container">${items}</div>
                         </div>
                     `;
                 };
                 inferenceContainer.innerHTML = `
                     <h3>Inferência Estatística e Plano de Ação</h3>
                     <div class="inference-grid">
                         ${generateInferenceHTML('Pontos Críticos', 'Alto volume e alta demora. Estas categorias são as mais problemáticas e requerem atenção prioritária.', quadrants.criticos, ICON_CRITICO, 'criticos')}
                         ${generateInferenceHTML('Pontos de Ineficiência', 'Baixo volume, mas alta demora. Sugere-se revisar o processo ou treinamento específico para estas tarefas.', quadrants.ineficientes, ICON_INEFICIENTE, 'ineficientes')}
                         ${generateInferenceHTML('Pontos Eficientes', 'Alto volume e baixa demora. Estas categorias podem servir como modelo de boas práticas para outras áreas.', quadrants.eficientes, ICON_EFICIENTE, 'eficientes')}
                     </div>
                 `;
             }
         };


        const updateSlaByCategoryChart = (data) => {
            const ctx = document.getElementById('slaByCategoryChart').getContext('2d');
            const slaByCategory = {};
             // Inicializa com todas as categorias presentes nos dados filtrados
             [...new Set(data.map(item => item.categoria))].filter(Boolean).forEach(cat => {
                 slaByCategory[cat] = { total: 0, withinSla: 0 };
             });

            data.forEach(item => {
                // Conta apenas itens que TÊM uma avaliação de SLA (withinSla não é nulo)
                if (item.withinSla !== null && item.categoria && slaByCategory[item.categoria]) {
                    slaByCategory[item.categoria].total++;
                    if (item.withinSla === true) { // Verifica explicitamente por true
                        slaByCategory[item.categoria].withinSla++;
                    }
                }
            });

            const labels = Object.keys(slaByCategory).sort();
            const complianceData = labels.map(cat => {
                const item = slaByCategory[cat];
                return item.total > 0 ? ((item.withinSla / item.total) * 100) : 0;
            });

            if (slaByCategoryChart) slaByCategoryChart.destroy();
             if (labels.length === 0) {
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                 slaByCategoryChart = null;
                 return;
             }

            slaByCategoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '% Dentro do SLA',
                        data: complianceData,
                        backgroundColor: 'rgba(159, 196, 25, 0.7)'
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { x: { beginAtZero: true, max: 100, ticks: { callback: value => `${value}%` } } }, // Adiciona % no eixo X
                    plugins: {
                        legend: { display: false },
                         tooltip: { callbacks: { label: context => ` ${context.dataset.label}: ${context.raw.toFixed(1)}%` } } // Tooltip com %
                    }
                }
            });
        };

        // FUNÇÃO REMOVIDA
        // const updateGroupingVolumeChart = (data) => { ... };

        const updateLocationRankingChart = (data) => {
            const ctx = document.getElementById('locationRankingChart').getContext('2d');

            const locationCounts = data.reduce((acc, item) => {
                 const key = item.Location || "Não definido"; // Usa o campo Location original
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sortedData = Object.entries(locationCounts).sort(([, a], [, b]) => b - a).slice(0, 15); // Top 15
            const labels = sortedData.map(item => item[0]);
            const values = sortedData.map(item => item[1]);

            if (locationRankingChart) locationRankingChart.destroy();
             if (labels.length === 0) {
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                 locationRankingChart = null;
                 return;
             }

            locationRankingChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Nº de Apontamentos',
                        data: values,
                        backgroundColor: 'rgba(239, 68, 68, 0.7)', // Cor de Alerta
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y', // Barras horizontais para melhor leitura de locais longos
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { x: { beginAtZero: true, ticks: { precision: 0 } } },
                    plugins: { legend: { display: false } }
                }
            });
        };


        const updateLocationCategoryHeatmap = (data) => {
            const ctx = document.getElementById('locationCategoryHeatmap').getContext('2d');

            const counts = {};
            data.forEach(item => {
                 if (item.Location && item.categoria) { // Usa Location e Categoria
                    if (!counts[item.Location]) counts[item.Location] = {};
                    counts[item.Location][item.categoria] = (counts[item.Location][item.categoria] || 0) + 1;
                }
            });

            // Considera apenas os top 20 locais com mais apontamentos para o heatmap
            const locationTotals = Object.keys(counts).map(loc => ({
                name: loc,
                total: Object.values(counts[loc]).reduce((a, b) => a + b, 0)
            })).sort((a, b) => b.total - a.total).slice(0, 20); // Top 20 Locais

            const locationLabels = locationTotals.map(l => l.name);
             // Pega todas as categorias presentes nos dados filtrados
             const categoryLabels = [...new Set(data.map(item => item.categoria).filter(Boolean))].sort();

            const heatmapData = [];
            let maxValue = 0;
            locationLabels.forEach(loc => {
                categoryLabels.forEach(cat => {
                    const value = counts[loc]?.[cat] || 0;
                    if (value > 0) heatmapData.push({ x: cat, y: loc, v: value }); // x=Categoria, y=Local
                    if (value > maxValue) maxValue = value;
                });
            });

            if (locationCategoryHeatmap) locationCategoryHeatmap.destroy();
             if (locationLabels.length === 0 || categoryLabels.length === 0 || heatmapData.length === 0) {
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                 locationCategoryHeatmap = null;
                 return;
             }

            // Ajuste na altura dinâmica pode ser necessário se houver muitos locais/categorias
            const estimatedHeight = Math.max(600, locationLabels.length * 30); // Exemplo: 30px por local
             ctx.canvas.parentElement.style.height = `${estimatedHeight}px`;

            locationCategoryHeatmap = new Chart(ctx, {
                type: 'matrix',
                data: {
                    datasets: [{
                        label: 'Concentração',
                        data: heatmapData,
                        backgroundColor: (context) => {
                            const value = context.dataset.data[context.dataIndex]?.v;
                            if (!value) return 'rgba(245, 245, 245, 0.5)';
                             // Usar raiz quadrada pode dar melhor contraste visual para valores baixos
                            const alpha = maxValue > 0 ? Math.sqrt(value / maxValue) : 0;
                            return `rgba(1, 70, 92, ${alpha})`; // Cor Primária com alpha variável
                        },
                        borderColor: 'white',
                        borderWidth: 1,
                        // Ajusta tamanho do quadrado baseado no número de itens nos eixos
                        width: ({ chart }) => (chart.chartArea || {}).width / categoryLabels.length - 1,
                        height: ({ chart }) => (chart.chartArea || {}).height / locationLabels.length - 1,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Importante para altura dinâmica
                    scales: {
                         x: { type: 'category', labels: categoryLabels, ticks: { autoSkip: false } }, // Eixo X = Categorias
                         y: { type: 'category', labels: locationLabels, offset: true, ticks: { autoSkip: false } } // Eixo Y = Locais
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: () => '',
                                label: (context) => {
                                    const v = context.dataset.data[context.dataIndex];
                                     // Formato: Local | Categoria: Valor
                                     return v ? `${v.y} | ${v.x}: ${v.v} apontamentos` : '';
                                }
                            }
                        }
                    }
                }
            });
        };


        // --- Funções Auxiliares (showError, openTab, showDefectDetails) ---
         const showError = (message) => {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
             // Esconde outros elementos
             document.getElementById('loading-container').style.display = 'none';
             document.getElementById('dashboard-content').style.display = 'none';
             document.getElementById('initial-message').style.display = 'none'; // Esconde msg inicial também
        };

        function openTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) tabcontent[i].style.display = "none";
            tablinks = document.getElementsByClassName("tab-link");
            for (i = 0; i < tablinks.length; i++) tablinks[i].className = tablinks[i].className.replace(" active", "");
            const targetTab = document.getElementById(tabName);
             if (targetTab) {
                 targetTab.style.display = "block";
             }
             // Adiciona a classe 'active' ao botão clicado
             if (evt && evt.currentTarget) {
                evt.currentTarget.className += " active";
             } else {
                  // Caso seja chamado programaticamente (ex: clearDashboardState)
                  // Tenta encontrar o botão correspondente e ativá-lo
                  const defaultTabButton = document.querySelector(`.tab-link[onclick*="'${tabName}'"]`);
                  if (defaultTabButton) defaultTabButton.className += " active";
             }


            // Redimensiona gráficos na aba ativa após um pequeno delay
            setTimeout(() => {
                const activeCharts = {
                    'visaoGeral': [histogramChart, monthlyResolutionRateChart, statusHistoryChart, detailsChart, heatmapChart],
                    'eficiencia': [resolutionScatterChart, slaByCategoryChart],
                    'localizacao': [locationRankingChart, locationCategoryHeatmap] // groupingVolumeChart REMOVIDO
                }[tabName] || [];

                activeCharts.forEach(chart => {
                     // Verifica se o gráfico existe e tem o método resize
                     if (chart && typeof chart.resize === 'function') {
                         try {
                           chart.resize();
                         } catch (e) {
                              console.warn("Erro ao redimensionar gráfico:", e, chart);
                         }
                     }
                });
            }, 50); // Aumentado ligeiramente o delay
        }

        function showDefectDetails(categoryName) {
             // Garante que currentFinalData tenha dados
             if (!currentFinalData || currentFinalData.length === 0) {
                 console.warn("showDefectDetails chamado sem dados em currentFinalData.");
                 return;
             }

            const categoryData = currentFinalData.filter(item => item.categoria === categoryName);
            const defectCounts = categoryData.reduce((acc, item) => {
                const defect = item.descricao || 'Não especificado';
                acc[defect] = (acc[defect] || 0) + 1;
                return acc;
            }, {});
            const sortedDefects = Object.entries(defectCounts)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 5); // Top 5

            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            modalTitle.textContent = `Top 5 Defeitos para: ${categoryName}`;
            if (sortedDefects.length === 0) {
                modalBody.innerHTML = '<p>Nenhum defeito específico encontrado para esta categoria nos filtros atuais.</p>';
            } else {
                const listItems = sortedDefects.map(([defect, count]) => `<li><strong>${defect}</strong>: ${count} ocorrência(s)</li>`).join('');
                modalBody.innerHTML = `<ol>${listItems}</ol>`;
            }
            document.getElementById('modal-container').style.display = 'flex';
        }

        // --- INICIALIZAÇÃO E EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {

             const projectSelector = document.getElementById('project-selector');
             const fileInput = document.getElementById('json-file-input');
             // const printButton = document.getElementById('print-button'); // REMOVIDO
             const body = document.body;
             const overlay = document.getElementById('drag-drop-overlay');
             const modalContainer = document.getElementById('modal-container');
             const modalCloseBtn = document.getElementById('modal-close-btn');
             const modalContent = document.getElementById('modal-content');

            // *** MODIFICADO: Carrega o projeto padrão ao iniciar ***
             const defaultProjectName = projectSelector.options[projectSelector.selectedIndex].text;
             loadProjectData(defaultProjectName);
            // ####################################################

             // Listener para o seletor de projeto
             projectSelector.addEventListener('change', (event) => {
                 const selectedOption = event.target.selectedOptions[0];
                 const projectName = selectedOption.text; // Pega o nome visível (Hotel, Centro Medico, etc.)
                 loadProjectData(projectName);
             });

            // Listeners para os filtros de data/detalhe
            const filterIds = [
                'spotted-filter', 'year-filter', 'month-filter', 'groupname-filter',
                'categoria-filter', 'tipo-filter', 'descricao-filter',
                'heatmap-year-filter', 'grouping-filter'
            ];
            filterIds.forEach(id => {
                const element = document.getElementById(id);
                 if (element) {
                    element.addEventListener('change', runUpdate);
                 }
            });

             // Listener para upload manual de arquivo
             fileInput.addEventListener('change', handleFileUpload);

             // Listener para botão de imprimir REMOVIDO
             // printButton.addEventListener('click', () => { window.print(); });

            // Listeners para Drag and Drop
            let dragCounter = 0;
            body.addEventListener('dragenter', (e) => { e.preventDefault(); e.stopPropagation(); dragCounter++; overlay.style.display = 'flex'; });
            body.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); }); // Necessário para o drop funcionar
            body.addEventListener('dragleave', (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 dragCounter--;
                 if (dragCounter === 0) {
                     overlay.style.display = 'none';
                 }
            });
            body.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                overlay.style.display = 'none';
                dragCounter = 0;
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                     processFile(files[0]); // Processa o primeiro arquivo solto
                }
            });

            // Listeners para o Modal
            const closeModal = () => modalContainer.style.display = 'none';
            modalCloseBtn.addEventListener('click', closeModal);
            modalContainer.addEventListener('click', (event) => {
                 // Fecha se clicar fora do conteúdo do modal
                 if (!modalContent.contains(event.target)) {
                     closeModal();
                 }
            });

            // Listeners para Impressão (antes/depois)
             let activeTabBeforePrint = 'visaoGeral';
             window.addEventListener('beforeprint', () => {
                 // Guarda a aba ativa
                 const activeTabLink = document.querySelector('.tab-link.active');
                 if (activeTabLink && activeTabLink.onclick) {
                      // Extrai o nome da aba da função onclick
                      const match = activeTabLink.onclick.toString().match(/'([^']+)'/);
                      if (match && match[1]) {
                          activeTabBeforePrint = match[1];
                      }
                 }
                 // Mostra todas as abas para impressão
                 document.querySelectorAll('.tab-content').forEach(tab => { tab.style.display = 'block'; });
                 
                  const allCharts = [ // groupingVolumeChart REMOVIDO
                       histogramChart, monthlyResolutionRateChart, statusHistoryChart, detailsChart, heatmapChart,
                       resolutionScatterChart, slaByCategoryChart,
                       locationRankingChart, locationCategoryHeatmap
                  ];
                 allCharts.forEach(chart => { if (chart && typeof chart.resize === 'function') chart.resize(); });
             });

             window.addEventListener('afterprint', () => {
                 // Restaura a visualização da aba que estava ativa
                 const activeLink = document.querySelector(`.tab-link[onclick*="'${activeTabBeforePrint}'"]`);
                  if (activeLink) {
                      openTab({ currentTarget: activeLink }, activeTabBeforePrint);
                  } else {
                       // Fallback para a primeira aba se algo der errado
                       openTab({ currentTarget: document.querySelector('.tab-link') }, 'visaoGeral');
                  }
                  
                   const allCharts = [ // groupingVolumeChart REMOVIDO
                       histogramChart, monthlyResolutionRateChart, statusHistoryChart, detailsChart, heatmapChart,
                       resolutionScatterChart, slaByCategoryChart,
                       locationRankingChart, locationCategoryHeatmap
                   ];
                  allCharts.forEach(chart => { if (chart && typeof chart.resize === 'function') chart.resize(); });
             });
        });
    </script>
</body>
</html>